<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PrideLzh</title>
  
  <subtitle>一蓑烟雨任平生</subtitle>
  <link href="https://blog.pridelzh.top/atom.xml" rel="self"/>
  
  <link href="https://blog.pridelzh.top/"/>
  <updated>2025-08-30T00:01:05.897Z</updated>
  <id>https://blog.pridelzh.top/</id>
  
  <author>
    <name>pridelizihao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云支教之旅</title>
    <link href="https://blog.pridelzh.top/posts/78862.html"/>
    <id>https://blog.pridelzh.top/posts/78862.html</id>
    <published>2025-08-29T09:25:34.797Z</published>
    <updated>2025-08-30T00:01:05.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“一代人有一代人的使命，一代人有一代人的担当。”<br>——题记</p></blockquote><p>盛夏的阳光炽烈而温柔，映照着城市的屋檐，也照进了屏幕两端的世界。这个暑假，我选择了一条不同寻常的道路——踏入“云支教”的实践旅程。借助互联网的桥梁，我与一位来自邻近城市的中学生相遇，在“云端”牵起了一段关于学习、成长与责任的缘分。</p><p>我仍清晰记得第一次连线时的情景。少年拘谨地坐在摄像头前，声音轻得像风拂过水面。我微笑着打破僵局，告诉他我们是一同学习的伙伴，而不是居高临下的讲解者。从那天起，我们制定了详尽的暑期学习计划，规划了语数英的复习安排，划定了每周的“云课堂”时段。课堂上，我引导他巩固基础知识，帮助他找到学习的薄弱环节，并带着他一步步拆解难题。渐渐地，我看到他的眼神里闪烁出自信的光芒，那是一束正在被点燃的希望。</p><p>除了课堂，我们还有一项特别的“云运动”计划。虽然身处不同的城市，但我们约定每周三下午共同完成一次“线上运动挑战”。我们会各自记录跑步的里程，分享自己的锻炼成果；有时候还会比拼平板支撑、俯卧撑次数，哪怕隔着屏幕，汗水依然是彼此的见证。一次次的挑战，让少年不再沉溺于手机和游戏，而是学会了用汗水收获力量。</p><p>更让我印象深刻的，是我们共同完成的“家乡风物探索”活动。我请他用手机拍摄自己家乡的风景和人文故事，再由我来帮他梳理资料，一起在“云端”制作出一份关于家乡文化的小小展示文案。他第一次认真去走访村头的古祠堂、河畔的老榕树、集市上的传统小吃摊；他第一次用镜头记录自己熟悉却从未留意的事物。当他骄傲地在屏幕前向我展示这些作品时，我仿佛也在和他一同重新认识这片土地。<strong>这种探索，不只是看风景，而是理解生活、理解家乡、理解文化本身。</strong></p><p>就在这样一段段看似平凡的互动中，我逐渐意识到，所谓“支教”，并不是“我给予，你接受”的单向流动，而是一场双向奔赴的成长之旅。少年的自信在慢慢发芽，而我在教与学之间也愈加明白自己的责任感与使命感。</p><p>这种实践经历，让我对“新时代文明实践”有了更加具体、真切的感受。文明实践并不是书本上的抽象概念，也不仅仅是高悬在标语上的口号。它深深嵌入到社会的肌理里，融入到一场场具体的活动中，渗透进一个个普通人的生活里。正如习近平总书记所强调的，新时代文明实践中心要成为“传播党的创新理论、弘扬时代新风、推动文化自信的重要阵地”。而我们所做的云支教，正是把这种理念落到实处，让文明之花在看似平凡的日常里悄然绽放。</p><p>国家提出建设新时代文明实践中心，是为了打通思想宣传、文化服务、社会治理的“最后一公里”。而“云支教”就是一条跨越空间的数字纽带，让教育资源与文化交流突破时空限制，实现更大范围的共享。尤其在“双减”政策落地的背景下，教育公平成为社会关注的焦点。云支教的形式，使更多中学生能够获得优质的学习资源与精神陪伴，让“每一个孩子都能在同一片星空下闪耀”不再是遥不可及的梦想。</p><p>与此同时，《志愿服务条例》也为我们提供了制度保障，明确指出志愿服务是促进社会进步、提升社会文明程度的重要力量。这让我更加坚信，云支教不仅是一次志愿行动，更是文明传递的生动实践。技术让世界的距离缩短，而志愿精神让心与心的距离拉近。数字文明与志愿服务交织在一起，正在为新时代社会治理注入新的温度与力量。</p><p>我渐渐发现，文明实践的意义不仅在于“给予”，更在于“激发”。通过陪伴和引导，我看到少年慢慢养成自主学习的习惯，学会利用身边的资源，探索自己家乡的独特魅力。这种改变，不是单纯的成绩提升，而是一种对生活的热爱与对未来的渴望。<strong>这正是新时代文明实践的核心所在：让更多人有能力、有勇气去追求更加美好的生活。</strong></p><p>站在更高的维度回望，云支教不仅关乎一个中学生的成长，更是社会文明程度提升的缩影。教育资源的共享、文化认同的建立、青少年精神世界的丰富，这些细微而深远的变化，最终会汇聚成推动社会前行的磅礴力量。</p><p>而在这股力量中，我们青年一代责无旁贷。青年是国家的未来与希望，我们不仅是文明果实的享用者，更是文明火炬的传递者。每一次云端的耐心讲解、每一段远隔千里的情感连接，都是对社会文明的默默贡献。正如习近平总书记所言：“青年兴则国家兴，青年强则国家强。”我们的志愿服务，不只是帮助别人，更是在塑造自己的精神品质，锤炼责任与担当。</p><p>或许，云支教本身无法改变社会的宏观格局，但它能点亮力所能及的角落。无数青年志愿者的一束束星光，终将汇聚成照亮时代前行的文明之河。当这样的星光愈加璀璨，新时代文明的航程，便会在我们这一代人的书写下，延伸得更加辽阔而壮丽。</p><p>“长风破浪会有时，直挂云帆济沧海。”云课堂暂告一段落，但文明的实践永远不会结束。那一端少年的眼神依旧闪亮，而我的心中也燃起更炽烈的信念：让青春与文明同行，让责任与梦想并肩，用我们一代人的脚步，去丈量新时代文明实践的广阔大地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“一代人有一代人的使命，一代人有一代人的担当。”&lt;br&gt;——题记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;盛夏的阳光炽烈而温柔，映照着城市的屋檐，也照进了屏幕两端的世界。这个暑假，我选择了一条不同寻常的道路——踏入“云支教”的实践旅程。借助互联网</summary>
      
    
    
    
    
    <category term="云支教" scheme="https://blog.pridelzh.top/tags/%E4%BA%91%E6%94%AF%E6%95%99/"/>
    
    <category term="社会实践" scheme="https://blog.pridelzh.top/tags/%E7%A4%BE%E4%BC%9A%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="志愿服务" scheme="https://blog.pridelzh.top/tags/%E5%BF%97%E6%84%BF%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>2-IA32处理器及寄存器</title>
    <link href="https://blog.pridelzh.top/posts/78454566788.html"/>
    <id>https://blog.pridelzh.top/posts/78454566788.html</id>
    <published>2025-05-23T08:42:39.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、IA32处理器简介"><a href="#一、IA32处理器简介" class="headerlink" title="一、IA32处理器简介"></a>一、IA32处理器简介</h1><ol><li>IA32系列处理器</li></ol><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747050199903.webp" alt="1747050199903.webp"></p><ol start="2"><li>保护地址方式&amp;实地址方式</li></ol><ul><li>IA32系列CPU有3种工作方式：<strong>保护方式（包含一种子工作方式：虚拟8086方式）</strong>、<strong>实地址方式</strong>、<strong>系统管理方式</strong></li></ul><p>（1）保护方式</p><ol><li>保护方式是IA32系列处理器的<strong>常态工作方式</strong>，可以<strong>发挥全部性能和特点</strong> ,windows、Linux都运行于保护方式</li><li>全部32根地址线有效，<strong>可寻址4GB物理地址空间</strong></li><li>支持存储器分段管理 &amp; 可选的存储器分页管理机制</li><li>支持虚拟存储器的实现，<strong>用于指定存储单元的是面向虚拟存储器的虚拟地址</strong></li><li>提供完善的保护机制</li><li>支持操作系统实现多任务管理</li><li>支持虚拟8086方式</li></ol><p>（2）实地址方式</p><ol><li>实地址方式是最初的工作方式：<ol><li>开机&#x2F;重新设置系统后，IA32工作于实地址方式</li><li>很久以前8086&#x2F;8088等只支持实地址方式</li></ol></li><li>实地址方式下<strong>只能访问最低1MB物理地址空间</strong>（00000H-FFFFFH）</li><li>实地址方式下只支持存储器分段管理，且每个段大小限于64KB，段内有效地址范围0000H-FFFFH。不支持分页</li><li>储管理机制。<strong>可以认为实地址方式下用于指定要访问存储单元的线性地址就是真实地址</strong></li><li>实地址方式无法发挥IA32处理器 全部性能</li><li>指令集、执行环境和保护方式相同</li><li>实地址方式常被称为<strong>实方式</strong></li></ol><p>（3）工作方式的切换<br><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747050901961.webp" alt="1747050901961.webp"></p><h1 id="二、通用寄存器及使用"><a href="#二、通用寄存器及使用" class="headerlink" title="二、通用寄存器及使用"></a>二、通用寄存器及使用</h1><ul><li>寄存器是处理器内的特殊存储单元</li><li>处理器内有多种不同用途的寄存器</li><li>寄存器分别有各自的名称，以便表示和访问</li></ul><ol><li>通用寄存器简介<ol><li>IA32系列CPU有<strong>8个32位通用寄存器</strong></li><li>通用寄存器用于<strong>存储数据</strong>、<strong>参与算数逻辑运算</strong>、<strong>给出存储单元地址</strong></li><li>名称：</li></ol><ul><li>32位：<code>EAX</code>,<code>EBX</code>,<code>ECX</code>,<code>EDX</code>,<code>ESI</code>,<code>EDI</code>,<code>EBP</code>,<code>ESP</code></li><li>16位：<code>AX</code>,<code>BX</code>,<code>CX</code>,<code>DX</code>,<code>BP</code>,<code>SI</code>,<code>DI</code>,<code>SP</code></li><li>8位：<code>AH</code>,<code>AL</code>,<code>BH</code>,<code>BL</code>,<code>CH</code>,<code>CL</code>,<code>DH</code>,<code>D</code><br> <img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747051079008.webp" alt="1747051079008.webp"></li></ul><ol start="4"><li>通用寄存器的高16位不可以单独使用，因为没有名字；但是可以单独用低16位、还可再拆开高低8位单独使用</li><li>通用寄存器的低16位叫：<code>AX</code>,<code>BX</code>,<code>CX</code>,<code>DX</code>,<code>BP</code>,<code>SI</code>,<code>DI</code>,<code>SP</code>，<strong>对应8086中的8个通用寄存器</strong></li><li>各寄存器作用简要说明</li></ol><ul><li><code>EAX</code>,<code>EBX</code>,<code>ECX</code>,<code>EDX</code>主要用于算术逻辑运算之中，如ADD&#x2F;SUB&#x2F;XOR&#x2F;OR等</li><li><code>ESI</code>,<code>EDI</code>,<code>EBP</code>,<code>ESP</code>主要用作保存内存地址的指针。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747051190119.webp" alt="1747051190119.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、IA32处理器简介&quot;&gt;&lt;a href=&quot;#一、IA32处理器简介&quot; class=&quot;headerlink&quot; title=&quot;一、IA32处理器简介&quot;&gt;&lt;/a&gt;一、IA32处理器简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;IA32系列处理器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="汇编语言" scheme="https://blog.pridelzh.top/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>1-基础知识</title>
    <link href="https://blog.pridelzh.top/posts/7845654.html"/>
    <id>https://blog.pridelzh.top/posts/7845654.html</id>
    <published>2025-05-23T08:38:58.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、CPU简介"><a href="#一、CPU简介" class="headerlink" title="一、CPU简介"></a>一、CPU简介</h1><ol><li><p>目标代码<br> &#x3D;&#x3D;目标代码&#x2F;目标程序：由机器指令组成的程序&#x3D;&#x3D;</p><ul><li>CPU只能执行机器指令</li><li>高级语言编写的程序，最后都要转换成机器指令组成的程序，即目标代码，这样才能执行</li><li>目标代码是二进制编码的</li></ul></li></ol><ul><li>程序编译过程<ul><li><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747049018950.webp" alt="1747049018950.webp"></li></ul></li></ul><ol start="2"><li><p>CPU基本功能<br> CPU的基本功能包括：&#x3D;&#x3D;执行机器指令、暂存少量数据、访问寄存器&#x3D;&#x3D;</p><p> 执行机器指令<br> 机器指令：CPU能直接识别并执行的指令<br> 指令集：一款CPU能执行的全部指令的集合<br> 指令的分类：<br> （1）数据传送指令<br> （2）转移指令<br> （3）处理器控制指令<br> （4）其他指令<br> 暂存少量数据<br> 大部分指令是对数据进行运算和处理。运算数据和运算结构存在<br> （1）寄存器（CPU中）<br> （2）存储器中（内存）<br> 利用CPU内寄存器存取运算数据和结果效率最高。汇编器会充分利用CPU中仅有的寄存器，编写汇编时也要注意<br> 访问存储器<br> 存储器：CPU可以直接访问的计算机系统的物理内存<br> 由机器指令组成的目标程序存储于存储器中，部分待处理数据也是<br> 存储器（内存）由一系列存储单元线性组成，最基本的存储单元为一个字节。为了标识和存取每一个单元，给每个单元一个编号（即地址）</p></li></ol><h1 id="二、汇编语言的概念"><a href="#二、汇编语言的概念" class="headerlink" title="二、汇编语言的概念"></a>二、汇编语言的概念</h1><ol><li>机器指令</li></ol><ul><li>由CPU直接识别并执行的指令称为机器指令，采用<strong>二进制编码</strong></li><li>一般由<code>操作码</code>和<code>操作数</code>两部分构成<br>  （1）<code>操作码</code>指出要进行的 <code>操作</code>&#x2F;<code>运算</code>…<br>  （2）<code>操作数</code>指出参与操作的 <code>对象</code>&#x2F;<code>结果存放位置</code>&#x2F;<code>数据</code>…</li><li>通常用<strong>十六进制形式写出机器指令</strong></li><li><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747049313452.webp" alt="1747049313452.webp"></li></ul><ol start="2"><li><p>汇编指令格式</p><ol><li>用指令助记符、地址符号等表示的指令称为汇编格式指令</li><li>格式：<code>[标号:] 指令助记符 [操作数表]</code>，其中<code>助记符</code>是必须的，<code>操作数</code>随指令而定，<code>标号</code>可有可无</li></ol></li><li><p>汇编语言的优缺点</p><ol><li>优：效率高</li><li>缺：繁琐、难调试</li></ol></li></ol><h1 id="三、数据的表示和存储"><a href="#三、数据的表示和存储" class="headerlink" title="三、数据的表示和存储"></a>三、数据的表示和存储</h1><ol><li><p>数值数据的表示</p><ul><li>数的二进制表示</li><li>有符号数的补码表示</li><li>符号扩展（扩展符号位）</li><li>数值数据表示范围</li><li>BCD码（常用8421）</li><li>十六进制表示(4位二进制转换1位十六进制，通常后加H)</li></ul></li><li><p>非数值数据表示</p><ul><li>ASCII码</li><li>变形国标码</li></ul></li><li><p>基本数据类型</p><ul><li>计算机存取的以二进制位表示的信息位数一般是8的倍数，有专门名称<br> <img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747049719596.webp" alt="1747049719596.webp"></li></ul></li><li><p>数据的存储</p></li></ol><ul><li>使用小端存储：数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、CPU简介&quot;&gt;&lt;a href=&quot;#一、CPU简介&quot; class=&quot;headerlink&quot; title=&quot;一、CPU简介&quot;&gt;&lt;/a&gt;一、CPU简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目标代码&lt;br&gt; &amp;#x3D;&amp;#x3D;目标代码&amp;#x2F;目标程序：由机器指令</summary>
      
    
    
    
    <category term="汇编语言" scheme="https://blog.pridelzh.top/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>0-基础概念</title>
    <link href="https://blog.pridelzh.top/posts/7868.html"/>
    <id>https://blog.pridelzh.top/posts/7868.html</id>
    <published>2025-05-23T08:36:49.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747048719342.webp" alt="1747048719342.webp"><br><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747048749989.webp" alt="1747048749989.webp"><br><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747048777898.webp" alt="1747048777898.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747048719342.webp&quot; alt=&quot;1747048719342.webp&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdn.jsdeli</summary>
      
    
    
    
    <category term="汇编语言" scheme="https://blog.pridelzh.top/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>6-LALR预测分析表</title>
    <link href="https://blog.pridelzh.top/posts/51.html"/>
    <id>https://blog.pridelzh.top/posts/51.html</id>
    <published>2025-05-16T13:28:41.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>研究LALR的原因</p><ul><li>规范LR分析表的状态数偏多</li></ul></li><li><p>LALR特点</p><ul><li>LALR和SLR的分析表有同样多的状态，比规范LR分析表要小得多</li><li>LALR的能力介于SLR和规范LR之间</li><li>LALR的能力在很多情况下已经够用</li></ul></li><li><p>LALR分析表构造方法</p><ul><li>通过合并规范LR(1)项目集来得到</li><li>合并核心项</li></ul></li></ul><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123918667.webp" alt="image.png"></p><p>写出自动机，发现有共同点<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124019042.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124348631.webp" alt="image.png"></p><p>合并之后的<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124451227.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124510893.webp" alt="image.png"></p><p>分析表<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124529509.webp" alt="image.png"></p><p>该报错的依旧是报错<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514124554044.webp" alt="image.png"></p><p>是否会引起冲突</p><p>对于 LR(1) 文法, 合并得到的 LALR(1) 分析表是否会引入冲突？</p><p>·     <strong>不会</strong>引入<strong>移入&#x2F;归约</strong>冲突</p><p>假设合并后出现冲突，[A → α·, a] 与 [B → β · aγ, b]</p><p>则在 LR(1) 自动机中, 存在某状态同时包含 [A → α·, a] 与 [B → β · aγ, c] (c随便是什么)</p><p>·     <strong>可能会</strong>引入<strong>归约&#x2F;归约</strong>冲突</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250516204236967.webp" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>语法分析: </p><p>自顶向下:  LL(1)</p><p>自底向上:  LR(0),  SLR(1), LALR(1), LR(1)</p><p>LL(1), LR(0), SLR(1), LALR(1), LR(1)文法之间的关系</p><p><a href="https://blog.csdn.net/zuzhiang/article/details/79047743">https://blog.csdn.net/zuzhiang/article/details/79047743</a></p><p>LR(0) &lt; SLR(1) &lt; LALR(1) &lt; LR(1)</p><p>即某个文法，如果是LR(0)文法，</p><p>那其一定是SLR(1)文法，</p><p>反过不成立。</p><p>什么是LR(0)文法?</p><p>LR(0)自动机, LR(0)分析表</p><p>LL(1) 和他们没关系</p><p>所有的二义性文法都不是上述文法.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;研究LALR的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规范LR分析表的状态数偏多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LALR特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LALR和SLR的分析表有同样多的状态，比规范LR分析表要小得多&lt;/li&gt;
&lt;li&gt;LALR的</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="LALR分析表" scheme="https://blog.pridelzh.top/tags/LALR%E5%88%86%E6%9E%90%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>5-LR(1)文法</title>
    <link href="https://blog.pridelzh.top/posts/50.html"/>
    <id>https://blog.pridelzh.top/posts/50.html</id>
    <published>2025-05-16T13:27:16.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<p>LR(1)文法和LR(0)文法相比，多了一个展望符的定义</p><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1746946369716.webp" alt="1746946369716.webp"></p><h1 id="1-使用增广文法"><a href="#1-使用增广文法" class="headerlink" title="1. 使用增广文法"></a>1. 使用增广文法</h1><p>这里有一个例子</p><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1746945923946.webp" alt="1746945923946.webp"></p><h1 id="2-画有限自动机"><a href="#2-画有限自动机" class="headerlink" title="2. 画有限自动机"></a>2. 画有限自动机</h1><p>这里有一个例子，请详看</p><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1746946828188.webp" alt="1746946828188.webp"></p><h1 id="3-LR-1-分析表"><a href="#3-LR-1-分析表" class="headerlink" title="3. LR(1)分析表"></a>3. LR(1)分析表</h1><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1746947134528.webp" alt="1746947134528.webp"></p><p>所以LR(1)和LR(0)的主要区别就是多了一个展望符号的定义，并且归约要写在展望符的下面</p><p>还有一道例题</p><p>给定文法<br>*<em>S→L&#x3D;R | R<br>L→<em>R | id<br>R→L</em></em></p><p>获得增广文法<br>**（0）S’→S<br>（1）S→L&#x3D;R<br>（2）S→R<br>（3）L→<em>R<br>（4）L→id<br>（5）R→L</em>*</p><p>画出自动机</p><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747013912623.webp" alt="1747013912623.webp"></p><p>根据自动机构造分析表</p><p><img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1747014069039.webp" alt="1747014069039.webp"></p><p><a href="https://blog.csdn.net/qq_40147863/article/details/93253171?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b9442f21f7e177e215173a27def57e47%2522%252C%2522scm%2522%253A%252220140713.130102334.wap%255Fall.%2522%257D&request_id=b9442f21f7e177e215173a27def57e47&biz_id=0&utm_medium=distribute.wap_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-93253171-null-null.wap_first_rank_v2_rank_v29&utm_term=LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98&spm=1018.2118.3001.4187">参考CSDN文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LR(1)文法和LR(0)文法相比，多了一个展望符的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pridelzh/blogbed@main/1746946369716.webp&quot; alt=&quot;1746946369716.we</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="LR分析" scheme="https://blog.pridelzh.top/tags/LR%E5%88%86%E6%9E%90/"/>
    
    <category term="LR(1)文法" scheme="https://blog.pridelzh.top/tags/LR-1-%E6%96%87%E6%B3%95/"/>
    
    <category term="LR(1)分析" scheme="https://blog.pridelzh.top/tags/LR-1-%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>4-SLR分析表</title>
    <link href="https://blog.pridelzh.top/posts/49.html"/>
    <id>https://blog.pridelzh.top/posts/49.html</id>
    <published>2025-05-16T13:26:06.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<p>构造SLR分析表本质上就是构造一个基于文法LR(0)项目的LR(0)自动机。LR(0)项目，LR(0)自动机</p><h2 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h2><p>在右部的某个地方加点的产生式<br>加点的目的是用来表示分析过程中的状态</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212237629.webp" alt="image.png"></p><h2 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="LR(0)自动机"></a>LR(0)自动机</h2><p>根据文法LR(0)项目构造识别可行前缀的DFA</p><p>LR(0)项   &#x3D;&gt; LR(0)自动机<br>文法的所有LR(0)项构成一组规范LR(0)项集，这些规范项集对应LR(0)自动机的状态。</p><h2 id="构造SLR分析表的两大步骤"><a href="#构造SLR分析表的两大步骤" class="headerlink" title="构造SLR分析表的两大步骤"></a>构造SLR分析表的两大步骤</h2><ol><li>从文法构造识别可行前缀的DFA</li><li>从上述DFA构造分析表</li></ol><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212452237.webp" alt="image.png"></p><p>接下来就是把增广文法分写来写成I0</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212543976.webp" alt="image.png"></p><p>接下来就是根据I0不断推进，并在对应的action，goto表格中记录下来</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212604374.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212617908.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212830939.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212850911.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508212916214.webp" alt="image.png"></p><p>如果出现动作冲突，那么该文法就不是SLR(1)的</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508213019782.webp" alt="image.png"></p><p>SLR(1)和LR(0)的语法分析表的区别就是，SLR(1)仅在FOLLOW集下写ri，而LR(0)是在action整行写下ri</p><p>以上就是构建SLR分析表的步骤，严格来时，SLR分析表是一种特殊的LR(0)分析表，在后面我们还会了解到更为特殊的规范LR方法，通常情况下称为LR(1)文法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构造SLR分析表本质上就是构造一个基于文法LR(0)项目的LR(0)自动机。LR(0)项目，LR(0)自动机&lt;/p&gt;
&lt;h2 id=&quot;LR-0-项目&quot;&gt;&lt;a href=&quot;#LR-0-项目&quot; class=&quot;headerlink&quot; title=&quot;LR(0)项目&quot;&gt;&lt;/a&gt;LR(</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="SLR分析表" scheme="https://blog.pridelzh.top/tags/SLR%E5%88%86%E6%9E%90%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>3-LR(0)语法分析</title>
    <link href="https://blog.pridelzh.top/posts/48.html"/>
    <id>https://blog.pridelzh.top/posts/48.html</id>
    <published>2025-05-16T13:24:34.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、LR语法分析器模型"><a href="#一、LR语法分析器模型" class="headerlink" title="一、LR语法分析器模型"></a>一、LR语法分析器模型</h2><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505112339877.webp" alt="image.png"></p><h2 id="二、LR语法分析算法"><a href="#二、LR语法分析算法" class="headerlink" title="二、LR语法分析算法"></a>二、LR语法分析算法</h2><p>输入：一个输入串w和一个LR语法分析表</p><p>输出：如果w在L(G)中，输出w的自底向上的语法分析过程中的归约步骤；否则给出错误提示</p><p>方法：最初，语法分析器栈中的内容为初试状态S0，输入缓冲区的内容为w $。然后，执行语法分析程序。</p><h3 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h3><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505112821884.webp" alt="image.png"></p><p>LR(0)的自动机<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250516185339268.webp" alt="image.png"></p><p>分析表<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505112954499.webp" alt="image.png"></p><p>分析过程<br><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505113022028.webp" alt="image.png"></p><h2 id="三、LR分析算法的特点"><a href="#三、LR分析算法的特点" class="headerlink" title="三、LR分析算法的特点"></a>三、LR分析算法的特点</h2><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505113326994.webp" alt="image.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>LR文法：我们能为之构造出所有条目都唯一的LR分析表。</p><p>直观上说，只要存在这样一个从左到右扫描的移入-归约语法分析器，它总是能够在某文法的最右句型的句柄出现在栈顶时识别出这个句柄，那么这个文法就是LR的。</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505113522799.webp" alt="image.png"></p><h3 id="特点集合"><a href="#特点集合" class="headerlink" title="特点集合"></a>特点集合</h3><ul><li><p>栈中的文法符号总是形成一个可行前缀</p></li><li><p>分析表的转移函数本质上是识别可行前缀的DFA</p></li><li><p>栈顶的状态符号包含了确定句柄所需要的一切信息</p></li><li><p>是已知的最一般的无回溯的移进——归约方法</p></li><li><p>能分析的文法类是预测分析法能分析的文法类的真超集</p></li><li><p>能及时发现语法错误</p></li><li><p>手工构造分析表的工作量太大</p></li></ul><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505113836002.webp" alt="image.png"></p><h2 id="四、LR分析方法和LL分析方法的比较"><a href="#四、LR分析方法和LL分析方法的比较" class="headerlink" title="四、LR分析方法和LL分析方法的比较"></a>四、LR分析方法和LL分析方法的比较</h2><h3 id="LR文法-vs-LL文法"><a href="#LR文法-vs-LL文法" class="headerlink" title="LR文法    vs    LL文法"></a>LR文法    vs    LL文法</h3><ul><li><p>LR(K)文法:向前看k个输入符号能够知道一个产生式的右部所能推导出的所有符号串，进而识别出这个产生式右部的出现。</p></li><li><p>LL(K)文法：看到了产生式右部推出的前k个符号后能够识别出用于归约的产生式。</p></li><li><p>LR文法比LL文法描述的语言更多。</p></li></ul><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505114132619.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505114204590.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505114226890.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505114244982.webp" alt="image.png"></p><h2 id="五、id-id-id的分析"><a href="#五、id-id-id的分析" class="headerlink" title="五、id* id + id的分析"></a>五、id* id + id的分析</h2><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250505112954499.webp" alt="image.png"></p><table><thead><tr><th>分析过程详解</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>状态栈</td><td>符号栈</td><td>输入</td><td>动作</td></tr><tr><td>$0</td><td>$</td><td>id * id + id $</td><td>s5</td></tr><tr><td>$0 5</td><td>$ id</td><td>* id + id $</td><td>r6 F -&gt;id</td></tr><tr><td>$ 0 3</td><td>$ F</td><td>* id + id $</td><td>r4 T -&gt;F</td></tr><tr><td>$ 0 2</td><td>$ T</td><td>* id + id $</td><td>S7</td></tr><tr><td>$ 0 2 7</td><td>$ T *</td><td>id + id $</td><td>S5</td></tr><tr><td>$ 0 2 7 5</td><td>$ T * id</td><td>+ id $</td><td>R6 F-&gt;id</td></tr><tr><td>$ 0 2 7 10</td><td>$ T * F</td><td>+ id $</td><td>R3 T-&gt;T * F</td></tr><tr><td>$ 0 2</td><td>$ T</td><td>+ id $</td><td>R2 E-&gt;T</td></tr><tr><td>$ 0 1</td><td>$ E</td><td>+ id $</td><td>S6</td></tr><tr><td>$ 0 1 6</td><td>$ E +</td><td>id $</td><td>S5</td></tr><tr><td>$ 0 1 6 5</td><td>$ E + id</td><td>$</td><td>R6 F-&gt;id</td></tr><tr><td>$ 0 1 6 3</td><td>$ E + F</td><td>$</td><td>R4 T-&gt;F</td></tr><tr><td>$ 0 1 6 9</td><td>$ E + T</td><td>$</td><td>R1 E-&gt;E+T</td></tr><tr><td>$ 0 1</td><td>$ E</td><td>$</td><td>acc</td></tr><tr><td>符号栈归约的时候，减少几个，状态栈就弹出几个元素</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、LR语法分析器模型&quot;&gt;&lt;a href=&quot;#一、LR语法分析器模型&quot; class=&quot;headerlink&quot; title=&quot;一、LR语法分析器模型&quot;&gt;&lt;/a&gt;一、LR语法分析器模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.gitcode.com/</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="LR分析" scheme="https://blog.pridelzh.top/tags/LR%E5%88%86%E6%9E%90/"/>
    
    <category term="LR(0)分析" scheme="https://blog.pridelzh.top/tags/LR-0-%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2-自底向上语法分析</title>
    <link href="https://blog.pridelzh.top/posts/47.html"/>
    <id>https://blog.pridelzh.top/posts/47.html</id>
    <published>2025-05-16T13:23:25.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、自底向上语法分析"><a href="#一、自底向上语法分析" class="headerlink" title="一、自底向上语法分析"></a>一、自底向上语法分析</h2><ul><li>一个自底向上语法分析过程对应于为一个输入串构造语法分析树的过程，它从叶子节点开始，逐步向上到达根节点。即把输入串归约成文法的开始符号。</li></ul><h2 id="二、规约"><a href="#二、规约" class="headerlink" title="二、规约"></a>二、规约</h2><ul><li><p>若一个子串和某个产生式的右部匹配，则用该产生式的左部符号代替这个子串。</p><p><img src="https://img.picgo.net/2025/05/04/image3cc7f6eafd1d2f50.png" alt="image"><br><img src="https://img.picgo.net/2025/05/04/imageedbf4764b8cbd1a8.png" alt="image"></p></li><li><p>归约可以看成是推导的逆过程</p></li></ul><h2 id="三、句柄"><a href="#三、句柄" class="headerlink" title="三、句柄"></a>三、句柄</h2><ul><li><p>句型的句柄是和某产生式右部匹配的子串，并且，把它归约成该产生式左部的非终结符代表了最右推导过程的逆过程的一步。<br><img src="https://img.picgo.net/2025/05/04/image3cbb7a0b231f740e.png" alt="image"></p></li><li><p>该段文字中蓝色部分就是句柄</p></li><li><p>如果说文法存在二义性，那么句柄可能不一致<br><img src="https://img.picgo.net/2025/05/04/image2d9cf14480187d12.png" alt="image"></p></li></ul><h2 id="四、用栈实现移进——归约语法分析"><a href="#四、用栈实现移进——归约语法分析" class="headerlink" title="四、用栈实现移进——归约语法分析"></a>四、用栈实现移进——归约语法分析</h2><ul><li>移进——归约语法分析是自底向上语法分析的一种形式。</li><li>使用栈来保存文法符号，并用一个输入缓冲区来存放将要进行语法分析的其余符号。</li><li>移进——归约语法分析的四种动作：<ul><li>移进：把下一个输入符号移进栈</li><li>归约：分析器知道句柄的右端已在栈顶，然后确定句柄的左端在栈中的位置，再决定用什么样的非终结符代替句柄</li><li>接受：分析器宣告分析成功</li><li>报错：分析器发现语法错误，调用错误恢复例程</li></ul></li></ul><p>下面是一个例子</p><h2 id="五、id1-id-id的归约语法分析"><a href="#五、id1-id-id的归约语法分析" class="headerlink" title="五、id1 * id + id的归约语法分析"></a>五、id1 * id + id的归约语法分析</h2><p><img src="https://img.picgo.net/2025/05/04/image122a3eb18196f96e.png" alt="image"></p><p>关于这个流程，大家可以仔细关注一下，通过这个流程，应该可以大致明白移进——规约的过程</p><h2 id="六、移进——归约分析的冲突"><a href="#六、移进——归约分析的冲突" class="headerlink" title="六、移进——归约分析的冲突"></a>六、移进——归约分析的冲突</h2><p><img src="https://img.picgo.net/2025/05/04/imagedc460dceb8599323.png" alt="image"></p><p><img src="https://img.picgo.net/2025/05/04/image8a1ed9a201f5c62c.png" alt="image"></p><p><img src="https://img.picgo.net/2025/05/04/image2c07b933d4110511.png" alt="image"></p><p><img src="https://img.picgo.net/2025/05/04/imageb0407866ca252915.png" alt="image"></p><h2 id="七、LR-0-分析表的构造"><a href="#七、LR-0-分析表的构造" class="headerlink" title="七、LR(0)分析表的构造"></a>七、LR(0)分析表的构造</h2><p>LR(0)分析表的构造过程涉及构建一个表格，用于指导编译器在分析源代码时确定下一步的动作。这个表格是基于LR(0)自动机，它是对文法的一个抽象表示，用于处理语法分析过程中的不确定性和冲突。以下是LR(0)分析表构造的基本步骤：</p><ol><li><p>定义文法：首先，需要有一个形式化的上下文无关文法，它描述了源代码的语法结构。</p></li><li><p>拓广文法：在原始文法的基础上，&#x3D;&#x3D;添加一个起始符号S’和一个产生式S’ → S&#x3D;&#x3D;，其中S是原始文法的开始符号。拓广文法用于处理输入结束的情况。</p></li><li><p>构建项目集族：项目是一个形如A → α.β的产生式，其中A是一个非终结符，α和β是终结符和非终结符的序列，&#x3D;&#x3D;点(.)表示当前分析的位置。项目集族是一系列的项目集&#x3D;&#x3D;，每个项目集包含一组项目。项目集族通过合并那些可以通过推导关系相互到达的项目集来构建。</p></li><li><p>计算闭包：对于每个项目集，计算其闭包，即包含所有可以通过零次或多次应用产生式的右侧推导到达的项目。&#x3D;&#x3D;闭包确保每个项目集都包含所有可能的状态&#x3D;&#x3D;。</p></li><li><p>构建ACTION表：ACTION表是一个二维表，其行代表项目集（状态），&#x3D;&#x3D;列代表输入符号（终结符和$，表示输入结束）&#x3D;&#x3D;。ACTION表的每个条目指定了一个动作，例如移进&#x3D;&#x3D;（shift）、规约（reduce）或接受（accept）。&#x3D;&#x3D;</p></li><li><p>构建GOTO表：GOTO表也是一个二维表，其行代表项目集（状态），&#x3D;&#x3D;列代表非终结符&#x3D;&#x3D;。GOTO表的每个条目指定了在遇到非终结符时应转移到的下一个状态。</p></li><li><p>处理冲突：在构建ACTION和GOTO表时，可能会遇到冲突，即对于同一状态和输入符号，有多个可能的动作。LR(0)文法要求没有移进-规约冲突和规约-规约冲突，否则文法不是LR(0)文法。</p></li><li><p>填充分析表：使用ACTION和GOTO表的信息填充LR(0)分析表。分析表的每一行对应一个项目集（状态），每一列对应一个输入符号。</p></li><li><p>验证分析表：最后，验证分析表是否正确地反映了文法的语法结构，确保所有合法的输入序列都可以通过分析表正确地被接受，并且所有非法的输入序列都被正确地拒绝。</p></li><li><p>在实际操作中，由于构造LR(0)分析表可能涉及复杂的算法和大量的手动工作，通常使用自动化工具如编译器生成器（如GCC的GCCXML，ANTLR，或者Yacc&#x2F;Bison等）来生成分析表。这些工具能够处理文法分析中的细节，生成高效且正确的代码。</p></li></ol><p>百读不如一做，下面是一个例子，读懂了，就知道该怎么做了</p><p>求表达式的自动机</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508190019979.webp"></p><p>关键步骤讲解，本题就是，我们先添加一个其实符号S’，之后就按照要求不断扩展，不断读取，写出这个DFA就可以了</p><p>写出增广文法，&#x3D;&#x3D;如果点后是一个非终结符，就要将该非终结符的所有移进状态加进去&#x3D;&#x3D;，对应上文的4，之后只剩终结符了，就不用添加了，然后再不断读取后面的一个符号，即将·移动到下一个字符的后面，根据字符的不同分类</p><p>S-&gt;bBB<br>S-&gt;·bBB 移进<br>S-&gt;bBB· 归约<br>S-&gt;b·BB 待约<br>S-&gt;bB·B 待约</p><p>根据文法和自动机来填写LR(0)语法分析表，根据上一个结果的自动机的状态，action中写终结符和$，goto中写非终结符，有三种选择，移进s，归约r，接受acc，一般情况下，状态1对应的 $要写上acc，如果有归约的状态就写上ri</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508193244708.webp" alt="Screenshot_20250508_173152_tv.danmaku.bilibilihd.jpg"></p><p>SLR(1)和LR(0)的语法分析表的区别就是，SLR(1)仅在FOLLOW集下写ri，而LR(0)是在action整行写下ri</p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250508193538686.webp" alt="Screenshot_20250508_173702_tv.danmaku.bilibilihd.jpg"></p><h2 id="八、项目闭包集"><a href="#八、项目闭包集" class="headerlink" title="八、项目闭包集"></a>八、项目闭包集</h2><p>项目集闭包<br>项目集闭包的概念是在编译原理的LR(0)分析表构造中引入的。在LR(0)分析中，一个项目是一个文法产生式和一个点的组合，形如A -&gt; α.β，其中A是非终结符，α和β是符号串（可以是终结符或非终结符），点.表示当前分析的位置。项目集是一个项目的集合，而项目集的闭包则包含了所有可以从初始项目集通过零次或多次应用产生式的右侧推导而到达的项目。</p><p>计算项目集闭包的过程包括：</p><ol><li>&#x3D;&#x3D;遍历项目集中的每个项目。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;对于每个项目，检查点后面的符号（非终结符）的所有产生式。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;如果这个符号有非ε产生式，就生成新的项目并添加到闭包中。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;如果这个符号有ε产生式，也生成新的项目并添加到闭包中。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;重复这个过程，直到没有新的项目可以添加到闭包中。&#x3D;&#x3D;</li></ol><p>项目集的闭包在构造LR(0)分析表时非常重要，因为它帮助确定在给定状态下分析器可以进行的所有可能的动作。通过计算闭包，可以确保分析表涵盖了所有必要的项目，从而正确地进行语法分析。</p><p>项目集闭包的概念是LR(0)分析表构造中的一个重要概念。在编译器设计中，特别是当构建语法分析器时，项目集闭包用于确定给定状态下分析器可以进行的所有可能动作。项目集闭包包含了所有可以通过零次或多次应用产生式的右侧推导而到达的项目。</p><p>一个项目通常表示为一个产生式，其中点（.）表示当前分析的位置。例如，对于产生式A -&gt; αBβ，A -&gt; α.Bβ表示Bβ尚未被分析的部分。项目集闭包计算过程中，会检查每个项目的点后面的符号，如果这是一个非终结符（即另一个语法规则左部的符号），则将其所有可能的产生式添加到闭包中。如果这个非终结符有ε-产生式（即它可以产生空字符串），则将相应的项目也添加到闭包中。</p><p>这个过程一直进行，直到没有新的项目可以添加到闭包中为止。最终得到的闭包项目集代表了在当前状态下，分析器可以进行的所有可能动作。这对于构建有效的语法分析器至关重要，因为它决定了分析器如何根据当前输入和已识别的语法结构来推进分析过程。</p><p>简而言之，项目集闭包是一个包含了所有可达项目的集合，这些项目代表了分析器在不同状态下可以进行的所有可能动作。它是编译器设计中语法分析器构建的一个关键步骤。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、自底向上语法分析&quot;&gt;&lt;a href=&quot;#一、自底向上语法分析&quot; class=&quot;headerlink&quot; title=&quot;一、自底向上语法分析&quot;&gt;&lt;/a&gt;一、自底向上语法分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个自底向上语法分析过程对应于为一个输入串构造语法分析树的过程，</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="自底向上语法分析" scheme="https://blog.pridelzh.top/tags/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    <category term="句柄" scheme="https://blog.pridelzh.top/tags/%E5%8F%A5%E6%9F%84/"/>
    
    <category term="规约" scheme="https://blog.pridelzh.top/tags/%E8%A7%84%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>1-构建LL分析表</title>
    <link href="https://blog.pridelzh.top/posts/46.html"/>
    <id>https://blog.pridelzh.top/posts/46.html</id>
    <published>2025-05-16T13:22:03.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一个文法G的每一个产生式A-&gt;a，进行如下处理：</p><ol><li><p>对于FIRST(A)中的每一个终结符号m，将A-&gt;a添加到[A,m]。</p></li><li><p>如果e在FIRST(A)中，那么对于FOLLOW(A)中的每一个终结符b，将A-&gt;a添加到M[A,b]中，如果e在FIRST(a)中，且$在FOLLOW(A)中，也将A-&gt;a加入M[A,$]。</p></li></ol><p>通俗一点来讲，就是建立一个通道，即是两个终结符之间通过什么可以完成可达性。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123328173.webp"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123410020.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123427631.webp" alt="image.png"></p><h1 id="特殊的"><a href="#特殊的" class="headerlink" title="特殊的"></a>特殊的</h1><p>一个文法的预测分析表有没有多重定义的条目，当且仅当该文法是LL(1)的</p><p>如果文法G是左递归或二义的，则M至少含一个多重定义的条目</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123445170.webp" alt="image.png"></p><p><img src="https://raw.gitcode.com/Pridelzh/blogbed/raw/main/20250514123512246.webp" alt="image.png"></p><p>id + id * id $ 的推导过程 (初始情况)</p><table><thead><tr><th>已匹配</th><th>栈</th><th>输入</th></tr></thead><tbody><tr><td></td><td>E $</td><td>id + id * id $</td></tr><tr><td></td><td>TE’ $</td><td>id + id * id $</td></tr><tr><td></td><td>FT’E’$</td><td>id + id * id $</td></tr><tr><td></td><td>idT’E’$</td><td>id + id * id $</td></tr><tr><td>id</td><td>T’E’$</td><td>+ id * id $</td></tr><tr><td>id</td><td>E’$</td><td>+ id * id $</td></tr><tr><td>id</td><td>+TE’$</td><td>+ id * id $</td></tr><tr><td>id +</td><td>TE’$</td><td>id * id $</td></tr><tr><td>id +</td><td>FT’ E’$</td><td>id * id $</td></tr><tr><td>id+</td><td>id T’ E’ $</td><td>id * id $</td></tr><tr><td>id + id</td><td>T’ E’ $</td><td>* id $</td></tr><tr><td>id + id</td><td>* FT’E’$</td><td>* id $</td></tr><tr><td>id + id *</td><td>FT’E’$</td><td>id $</td></tr><tr><td>id + id *</td><td>idT’E’$</td><td>id$</td></tr><tr><td>id + id * id</td><td>T’E’$</td><td>$</td></tr><tr><td>id + id * id</td><td>E’$</td><td>$</td></tr><tr><td>id + id * id</td><td>$</td><td>$</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;对于一个文法G的每一个产生式A-&amp;gt;a，进行如下处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于FIRST(A)中的每一个终结符号m，将A-</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="文法" scheme="https://blog.pridelzh.top/tags/%E6%96%87%E6%B3%95/"/>
    
    <category term="预测分析表" scheme="https://blog.pridelzh.top/tags/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>0-LL文法</title>
    <link href="https://blog.pridelzh.top/posts/45.html"/>
    <id>https://blog.pridelzh.top/posts/45.html</id>
    <published>2025-05-16T13:18:36.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LL文法的两个函数"><a href="#LL文法的两个函数" class="headerlink" title="LL文法的两个函数"></a>LL文法的两个函数</h1><p>FIRST AND FOLLOW</p><ul><li>花了很长时间，终于搞明白了LL文法的FIRST和FOLLOW相关的内容，希望对大家有所帮助</li></ul><h2 id="FIRST"><a href="#FIRST" class="headerlink" title="FIRST"></a>FIRST</h2><ul><li><strong>对于FIRST(α)我们看产生式头可以推导得到的产生式体中的首个符号集合</strong>，即计算FIRST时非终结符号处于产生式的头部。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>FIRST（a）被定义为可以从a推导得到的串的首符号的集合，其中a是任意的文法符号串</p></li><li><p>FIRST（a）&#x3D;｛a&#x3D;&gt;*b…,b是终结符｝</p></li><li><p>如果a&#x3D;&gt;*e,e也属于FIRST（a）</p></li></ol><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li><p>如果X是终结符，那么FIRST(X)&#x3D;X</p></li><li><p>如果X-&gt;Y1Y2Y3…Yk，且a在FIRST(Yi)中，且Y1&#x3D;&gt;*e,Y2&#x3D;&gt;*e,…,Yi-1&#x3D;&gt;*e，那么a在FIRST(X)中</p></li><li><p>如果X-&gt;e，那么e在FIRST(X)中</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://i.postimg.cc/mZ6yByBw/1280-X1280.png"></p><h2 id="FOLLOW"><a href="#FOLLOW" class="headerlink" title="FOLLOW"></a>FOLLOW</h2><ul><li>计算FOLLOW时非终结符号位于产生式体中，查看当前产生式体中（或者叫句型的右边部分）非终结符号紧挨着的 <strong>终结符号</strong> 集合。</li></ul><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li><p>FOLLOW（A）被定义为可能紧跟在A右边的终极符的集合</p></li><li><p>FOLLOW（A）&#x3D;｛a，S&#x3D;&gt;*…Aa…,a是终结符｝</p></li><li><p>如果说A是某个句型的最右符号，那么$属于FOLLOW（A）</p></li></ol><h3 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h3><ol><li><p>将$放到FOLLOW(S)中，S是开始符号，$是输入右端的结束标志</p></li><li><p>如果存在A-&gt;aBC，那么FIRST（C）中非空的符号都在FOLLOW(B)中</p></li><li><p>如果存在A-&gt;aB，或A-&gt;aBC且FIRST（C）中包含e，则FOLLOW(A)中的所有符号都在FOLLOW(B)中</p></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://i.postimg.cc/WbF63q4P/1280-X1280-1.png"></p><h1 id="根据文法推FIRST和FOLLOW"><a href="#根据文法推FIRST和FOLLOW" class="headerlink" title="根据文法推FIRST和FOLLOW"></a>根据文法推FIRST和FOLLOW</h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://i.postimg.cc/rFBGtydR/1280-X1280-2.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>我们对下面文法来求解FIRST和FOLLOW集合：</p><p>E→TE′</p><p>E′→+TE′ | ϵ</p><p>T→FT′</p><p>T′→∗FT′ | ϵ</p><p>F→(E) | id</p><p>首先我们以非终结符号出现的顺序，将它们按照顺序排列起来（有点像消除左递归时，我们创建的非终结符号集合）： E, T, E′, F, T′</p><p>1）、 <strong>非终结符号E</strong> ：</p><p>FIRST(E) &#x3D; { ( , <strong>id</strong> }，其推导过程为： E⇒TE′⇒FT′E′⇒(E)T′E′ | idT′E′；</p><p>FOLLOW(E) &#x3D; { ), $ }。从产生式 F→(E) 我们可以得到一个终结符号。而且从求FOLLOW的第一点可知，对于开始符号，我们需要将$添加进去。</p><p>2）、 <strong>非终结符号E’</strong>：</p><p>FIRST(E’) &#x3D; { +, ε }，其推导过程为：E′→+TE′ | ϵ。</p><p>FOLLOW(E’) &#x3D; { ), $ }，这是因为产生式 E→TE′ 可知，FOLLOW(E)和FOLLOW(E’)是完全等价的。</p><p>3）、 <strong>非终结符号T</strong>： FIRST(T) &#x3D; { ( , <strong>id</strong> }，其推导过程为： T⇒FT′⇒(E)T′E′ | idT′E′</p><p>FOLLOW(T)的计算从上述的文法中可以看出，非终结符号T出现在产生式体中的有 TE′, +TE′ ，也就是在其后面的均为非终结符号E’。因此FOLLOW(T)包含FIRST(E’)；</p><p>由于E’可以推导出空串ε，而且根据产生式 E→TE′。我们可以知道FOLLOW(T)同样等于FOLLOW(E)。因此求出上面两个的并集为：</p><p>FOLLOW(T) &#x3D; { +, ), $ }。</p><p>4）、 <strong>非终结符号T‘</strong>： FIRST(T’) &#x3D; { * ，ε <em>}，其推导过程为：T′→∗FT′ | ϵ</em>；</p><p>FOLLOW(T’) &#x3D; { +, ), $ }。这是因为根据产生式 T→FT′ 可知，FOLLOW(T’)和FOLLOW(T)是相同的；</p><p>5）、 <strong>非终结符号F</strong>： FIRST(F) &#x3D; { (, <strong>id</strong> }，其推导过程为 F→(E) | id；</p><p>FOLLOW(F)的计算和非终结符号T是类似的，首先我们根据产生式 T→FT′, T′→∗FT′可知，非终结符号F其后紧跟着非终结符号T’，因此FOLLOW(F)则包含了FIRST(T’)；</p><p>而且我们从产生式 T→FT′, T′→∗FT′ | ϵ 可知，T’可以推导出空串ε，因此FOLLOW(F)也包含有FOLLOW(T)；</p><p>因此最终的结论为：FOLLOW(F) &#x3D; { *, +, ), $ }</p><h1 id="判断是否为LL（1）文法"><a href="#判断是否为LL（1）文法" class="headerlink" title="判断是否为LL（1）文法"></a>判断是否为LL（1）文法</h1><p>LL(1)中的第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，而“1”则表示在每一步中只需要向前看一个输入符号来决定语法分析动作。我们利用LL(1)的文法，可以构造出不需要回溯的递归下降语法分析器（即预测分析器）。</p><ul><li>左递归文法和二义性文法都不可能是LL(1)的</li></ul><p>对于任意两个不同的产生式：A→α | β，只有满足下面条件时，它们才是LL(1)文法：</p><p>1）、不存在终结符号a，使得 α 和 β 都能够推导出以 a 开头的串；</p><p>意思也就是说，FIRST(α) 和 FIRST(β) 是不相交的集合。</p><p>2）、 <strong>α和β中最多只有一个可以推导出空串</strong>；</p><p>当然这里一样的，FIRST(α) 和 FIRST(β) 是不相交的集合。如果出现了相交的集合，那么交集就是 ε 集。</p><p>3）、如果 β→*ϵ，那么 α 不能推导出任何以 FOLLOW(A) 中某个终结符号开头的串。类似的，对于 α 也一样；</p><p>这里我仔细的说一下，如果要推导出以FOLLOW(A)中某个终结符号开头的串，那也就是说 FIRST(α) 和 FOLLOW(A) 要存在交集。对于推导 β→*ϵ 而言，我们从第二点可以知道，那么此时 α 不能推导出 ε。这样看来要 FIRST(α) 和 FOLLOW(A) 存在交集，那是不可能发生的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LL文法的两个函数&quot;&gt;&lt;a href=&quot;#LL文法的两个函数&quot; class=&quot;headerlink&quot; title=&quot;LL文法的两个函数&quot;&gt;&lt;/a&gt;LL文法的两个函数&lt;/h1&gt;&lt;p&gt;FIRST AND FOLLOW&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;花了很长时间，终于搞明白</summary>
      
    
    
    
    <category term="编译原理" scheme="https://blog.pridelzh.top/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>我的图床探索之旅：从踩坑到最优解</title>
    <link href="https://blog.pridelzh.top/posts/564.html"/>
    <id>https://blog.pridelzh.top/posts/564.html</id>
    <published>2025-05-05T02:00:00.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的图床探索之旅：从踩坑到最优解"><a href="#我的图床探索之旅：从踩坑到最优解" class="headerlink" title="我的图床探索之旅：从踩坑到最优解"></a>我的图床探索之旅：从踩坑到最优解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人博客时，图床的选择让我走了不少弯路。经过几天的反复测试，我终于找到了一套稳定高效的解决方案。本文将详细介绍我的探索历程，希望能帮助到有同样需求的朋友。</p><h2 id="一、云服务商方案体验"><a href="#一、云服务商方案体验" class="headerlink" title="一、云服务商方案体验"></a>一、云服务商方案体验</h2><h3 id="1-阿里云OSS"><a href="#1-阿里云OSS" class="headerlink" title="1. 阿里云OSS"></a>1. 阿里云OSS</h3><p><strong>使用体验</strong>：</p><ul><li>上传速度：★★★★☆</li><li>访问速度：★★★★★</li><li>管理界面：★★★☆☆</li></ul><p><strong>痛点</strong>：</p><ol><li>备案流程繁琐，耗时3天才完成，一般人不太容易拿到域名的备案，需要域名费用＋对象存储费用+服务器费用，其中服务器费用太过巨大</li><li>费用计算复杂，一不小心就会超支</li><li>防盗链设置不够灵活</li></ol><h3 id="2-腾讯云COS"><a href="#2-腾讯云COS" class="headerlink" title="2. 腾讯云COS"></a>2. 腾讯云COS</h3><p><strong>使用体验</strong>：</p><ul><li>上传速度：★★★★★</li><li>访问速度：★★★★☆</li><li>管理界面：★★★★☆</li></ul><p><strong>痛点</strong>：</p><ol><li>与阿里云类似需要备案</li><li>API文档不够友好</li></ol><h2 id="3-cloudfare-R2存储"><a href="#3-cloudfare-R2存储" class="headerlink" title="3.cloudfare R2存储"></a>3.cloudfare R2存储</h2><p>总结</p><ol><li>这个听说很好用，但是有一个致命缺点，你需要有信用卡或者PayPal账号</li><li>虽然国内的银联卡理论上也可以注册，但是国内的卡没有安全码，注册PayPal也有一定困难</li></ol><h2 id="二、成品图床深度评测"><a href="#二、成品图床深度评测" class="headerlink" title="二、成品图床深度评测"></a>二、成品图床深度评测</h2><h3 id="1-SM-MS"><a href="#1-SM-MS" class="headerlink" title="1. SM.MS"></a>1. <a href="https://sm.ms/">SM.MS</a></h3><p><strong>优点</strong>：</p><ul><li>开箱即用</li><li>国内访问速度快</li><li>支持API调用</li></ul><p><strong>致命缺陷</strong>：</p><ul><li>免费版5GB空间很快用完</li><li>图片管理功能简陋</li><li>不支持批量操作</li><li>这个是全外文的，感觉有种不靠谱的感觉，不建议大家使用</li></ul><h3 id="2-PostImage"><a href="#2-PostImage" class="headerlink" title="2. PostImage"></a>2. <a href="https://postimg.cc/">PostImage</a></h3><p><strong>亮点</strong>：</p><ul><li>完全匿名使用</li><li>无存储限制</li><li>界面简洁</li></ul><p><strong>问题</strong>：</p><ul><li>国外服务器有时加载慢</li><li>图片可能被无故删除</li><li>无内容管理后台</li></ul><h2 id="三、自建方案折腾记"><a href="#三、自建方案折腾记" class="headerlink" title="三、自建方案折腾记"></a>三、自建方案折腾记</h2><h3 id="1-GitHub-jsDelivr"><a href="#1-GitHub-jsDelivr" class="headerlink" title="1. GitHub+jsDelivr"></a>1. GitHub+jsDelivr</h3><p><a href="https://github.com/">GitHub</a></p><p><strong>优势</strong>：</p><ul><li>完全免费</li><li>版本控制</li><li>无限存储</li></ul><p><strong>坑点</strong>：</p><ul><li>国内访问时好时坏</li><li>大文件支持有限</li><li>需要技术基础</li></ul><h3 id="2-Gitee方案"><a href="#2-Gitee方案" class="headerlink" title="2. Gitee方案"></a>2. Gitee方案</h3><p><a href="https://gitee.com/">Gitee</a></p><p><strong>使用感受</strong>：</p><ul><li>国内访问速度极快 ★★★★★</li><li>审核严格到令人发指</li><li>经常无故封禁图片</li><li>外链流量限制严格</li></ul><p><strong>惨痛经历</strong>：</p><ol><li>三次因”内容违规”被删除图片</li><li>某篇文章突然所有图片失效</li><li>客服响应慢，解封困难</li></ol><h3 id="3-GitCode方案"><a href="#3-GitCode方案" class="headerlink" title="3. GitCode方案"></a>3. GitCode方案</h3><p><a href="https://gitcode.com/">Gitcode</a></p><p><strong>惊喜</strong>：</p><ul><li>国内访问飞快</li><li>审核比Gitee宽松</li><li>免费额度充足</li></ul><p><strong>不足</strong>：</p><ul><li>单文件限制50MB</li><li>偶尔抽风</li><li>文档较少</li></ul><h2 id="四、我的终极方案"><a href="#四、我的终极方案" class="headerlink" title="四、我的终极方案"></a>四、我的终极方案</h2><p>经过反复测试，我最终采用三级存储架构：（我同时会在下面放几张图片作为示例）</p><ol><li><p>​<strong>主力图床</strong>：GitCode自建</p><ul><li>存放所有文章配图</li><li>使用PicGo客户端管理  ，这里推荐大家这样使用，但是也可以手动操作，毕竟我们是个人使用，数据量不会太大<br>  <img src="https://raw.gitcode.com/Pridelzh/blogbed/files/main/OIP-C.jpeg"></li></ul></li><li><p>​<strong>备用图床</strong>：PostImage</p><ul><li>临时图片存放</li><li>应急使用<br>  <img src="https://i.postimg.cc/59hqNVX7/842bf2950a03419da9c97742467609e6.png"></li></ul></li><li><p>​<strong>网盘备份</strong>：一刻相册</p><ul><li>重要图片备份</li><li>原始文件存储<br>  <img src="https://cdn.jsdelivr.net/gh/pridelzh/blogbed/31e0eae3ed694039857d506d9b41f24c.png"></li></ul></li></ol><h2 id="五、血泪教训总结"><a href="#五、血泪教训总结" class="headerlink" title="五、血泪教训总结"></a>五、血泪教训总结</h2><ol><li>​<strong>不要相信永久免费</strong>：多个服务后来都开始收费</li><li>​<strong>备份！备份！备份</strong>：我因此丢失过几十张图片</li><li>​<strong>关注访问速度</strong>：不同地区访问差异很大</li><li>​<strong>API支持很重要</strong>：手动上传迟早会疯</li></ol><h2 id="六、给新手的建议"><a href="#六、给新手的建议" class="headerlink" title="六、给新手的建议"></a>六、给新手的建议</h2><ol><li>从GitCode开始尝试</li><li>一定要配置PicGo工具，我这里不知道为什么，总是配置不好，所以我还是一直手动上传加复制外链</li><li>保持多个备份渠道</li><li>定期检查图片可用性</li></ol><h2 id="七、未来优化方向"><a href="#七、未来优化方向" class="headerlink" title="七、未来优化方向"></a>七、未来优化方向</h2><ol><li>研究Cloudflare R2方案</li><li>尝试自建MinIO集群</li><li>开发自动化监控脚本</li><li>如果说大家有会配置picgo的，还请教我一下</li></ol><p>最后在此重申一下，本人最终采取的方案是Picgo官方图床，配合腾讯云cos存储，和GitHub自建图床一起使用，其中腾讯云是收费的，其他的免费</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的图床探索之旅：从踩坑到最优解&quot;&gt;&lt;a href=&quot;#我的图床探索之旅：从踩坑到最优解&quot; class=&quot;headerlink&quot; title=&quot;我的图床探索之旅：从踩坑到最优解&quot;&gt;&lt;/a&gt;我的图床探索之旅：从踩坑到最优解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="开发" scheme="https://blog.pridelzh.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="图床" scheme="https://blog.pridelzh.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>self-introduction</title>
    <link href="https://blog.pridelzh.top/posts/456132333.html"/>
    <id>https://blog.pridelzh.top/posts/456132333.html</id>
    <published>2025-04-28T00:00:00.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>大家好，非常开心，能够在这里和大家见面。</p><p>我再次希望向大家介绍一下我的个人代码托管平台，GitHub和gitee。</p><p>如果大家感兴趣，可以前往看看，希望能够对于你有所帮助</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://github.com/pridelizihao">GitHub</a></h1><h1 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a><a href="https://gitee.com/pridelzh">Gitee</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h1&gt;&lt;p&gt;大家好，非常开心，能够在这里和大家见面。&lt;/p&gt;
&lt;p&gt;我再次希望向大家介绍一下我的个人代码托管平台，GitHub和gite</summary>
      
    
    
    
    <category term="introduction" scheme="https://blog.pridelzh.top/categories/introduction/"/>
    
    <category term="生活" scheme="https://blog.pridelzh.top/categories/introduction/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="self-introduction" scheme="https://blog.pridelzh.top/tags/self-introduction/"/>
    
    <category term="introduction" scheme="https://blog.pridelzh.top/tags/introduction/"/>
    
  </entry>
  
  <entry>
    <title>多重背包问题</title>
    <link href="https://blog.pridelzh.top/posts/202501121200.html"/>
    <id>https://blog.pridelzh.top/posts/202501121200.html</id>
    <published>2025-02-10T04:00:00.000Z</published>
    <updated>2025-02-10T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>多重背包问题是一个经典的动态规划问题。在这个问题中，我们有 <code>N</code> 件物品，每件物品都有一个体积、一个价值和一个数量上限。我们的目标是将这些物品放入一个容量为 <code>V</code> 的背包中，使得背包中的物品总价值最大。</p><h2 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h2><p>我们使用动态规划来解决这个问题。定义 <code>dp[i][j]</code> 表示前 <code>i</code> 件物品恰好放入一个容量为 <code>j</code> 的背包可以获得的最大价值。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>状态转移方程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j], dp[i-1][j-k * wi] + k * vi)</span><br></pre></td></tr></table></figure><p>其中 <code>0 &lt;= k &lt;= si</code>，<code>wi</code> 是第 <code>i</code> 件物品的体积，<code>vi</code> 是第 <code>i</code> 件物品的价值，<code>si</code> 是第 <code>i</code> 件物品的数量上限。</p><h2 id="原始代码实现"><a href="#原始代码实现" class="headerlink" title="原始代码实现"></a>原始代码实现</h2><p>以下是原始的多重背包问题的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N, V = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 体积，价值，数量</span></span><br><span class="line">    wi, vi, si = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">min</span>(j // wi, si) + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k * wi] + k * vi)</span><br><span class="line"><span class="built_in">print</span>(dp[N][V])</span><br></pre></td></tr></table></figure><h2 id="优化：二进制拆分"><a href="#优化：二进制拆分" class="headerlink" title="优化：二进制拆分"></a>优化：二进制拆分</h2><p>为了优化上述算法，我们可以使用二进制拆分的方法，将物品的数量转化为多个物品。这样可以减少状态转移的复杂度。</p><h3 id="优化代码实现"><a href="#优化代码实现" class="headerlink" title="优化代码实现"></a>优化代码实现</h3><p>以下是优化后的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">N, V = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">w = []</span><br><span class="line">v = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    wi, vi, si = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= si:</span><br><span class="line">        w.append(wi * k)</span><br><span class="line">        v.append(vi * k)</span><br><span class="line">        si -= k</span><br><span class="line">        k *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> si != <span class="number">0</span>:</span><br><span class="line">        w.append(wi * si)</span><br><span class="line">        v.append(vi * si)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dp数组</span></span><br><span class="line">dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V, w[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(dp[V])</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过动态规划和二进制拆分的方法，我们可以有效地解决多重背包问题。优化后的代码在处理大规模数据时表现更佳，减少了计算复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多重背包问题&quot;&gt;&lt;a href=&quot;#多重背包问题&quot; class=&quot;headerlink&quot; title=&quot;多重背包问题&quot;&gt;&lt;/a&gt;多重背包问题&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问</summary>
      
    
    
    
    <category term="大学" scheme="https://blog.pridelzh.top/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://blog.pridelzh.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="算法" scheme="https://blog.pridelzh.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://blog.pridelzh.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>DFS回溯</title>
    <link href="https://blog.pridelzh.top/posts/d054201b.html"/>
    <id>https://blog.pridelzh.top/posts/d054201b.html</id>
    <published>2025-01-17T08:00:00.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯法求排列数"><a href="#回溯法求排列数" class="headerlink" title="回溯法求排列数"></a>回溯法求排列数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">depth</span>):</span><br><span class="line">    <span class="comment"># depth: 当前深度</span></span><br><span class="line">    <span class="keyword">if</span> depth == n:</span><br><span class="line">        <span class="comment"># 到达叶子节点，输出路径</span></span><br><span class="line">        <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择范围</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 已经访问过的节点，跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vis[i]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 符合条件的节点，加入路径</span></span><br><span class="line">        vis[i] = <span class="literal">True</span></span><br><span class="line">        path.append(i)</span><br><span class="line">        dfs(depth+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 回溯的时候，将当前节点从路径中移除</span></span><br><span class="line">        vis[i] = <span class="literal">False</span></span><br><span class="line">        path.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">vis = [<span class="literal">False</span>] * (n+<span class="number">1</span>)</span><br><span class="line">path = []</span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="回溯法求子集"><a href="#回溯法求子集" class="headerlink" title="回溯法求子集"></a>回溯法求子集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line">path = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">depth</span>):</span><br><span class="line">    <span class="keyword">if</span> depth == n:</span><br><span class="line">        <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择当前节点</span></span><br><span class="line">    path.append(a[depth])</span><br><span class="line">    dfs(depth+<span class="number">1</span>)</span><br><span class="line">    path.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不选择当前节点</span></span><br><span class="line">    dfs(depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="1508N皇后问题"><a href="#1508N皇后问题" class="headerlink" title="1508N皇后问题"></a>1508N皇后问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 N×N 的方格棋盘放置了 N 个皇后，使得它们不相互攻击（即任意 2 个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成 45 角的斜线上。你的任务是，对于给定的 N，求出有多少种合法的放置方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span> (x):</span><br><span class="line">    <span class="keyword">if</span> x == n + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">global</span> ans</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 枚举每一列</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 当前坐标(x,y)</span></span><br><span class="line">        <span class="keyword">if</span> vis1[y] <span class="keyword">or</span> vis2[x+y] <span class="keyword">or</span> vis3[x-y+n]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 标记当前坐标</span></span><br><span class="line">        vis1[y] = <span class="literal">True</span></span><br><span class="line">        vis2[x+y] = <span class="literal">True</span></span><br><span class="line">        vis3[x-y+n] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        dfs(x+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 回溯</span></span><br><span class="line">        vis1[y] = <span class="literal">False</span></span><br><span class="line">        vis2[x+y] = <span class="literal">False</span></span><br><span class="line">        vis3[x-y+n] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">vis1 = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">vis2 = [<span class="literal">False</span>]*(<span class="number">2</span>*n+<span class="number">1</span>)</span><br><span class="line">vis3 = [<span class="literal">False</span>]*(<span class="number">2</span>*n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小朋友崇拜圈"><a href="#小朋友崇拜圈" class="headerlink" title="小朋友崇拜圈"></a>小朋友崇拜圈</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>班里 N 个小朋友，每个人都有自己最崇拜的一个小朋友（也可以是自己）。</p><p>在一个游戏中，需要小朋友坐一个圈，每个小朋友都有自己最崇拜的小朋友在他的右手边。</p><p>求满足条件的圈最大多少人？</p><p>小朋友编号为 1,2,3,⋯N</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 走到x位置，当前长度为length</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, length</span>):</span><br><span class="line">    vis[x] = length</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 走到下一个点</span></span><br><span class="line">    <span class="comment"># 判断是否走过</span></span><br><span class="line">    <span class="keyword">if</span> vis[a[x]] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">global</span> ans</span><br><span class="line">        <span class="comment"># 此时存在环</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, length-vis[a[x]]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(a[x], length+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line">vis = [<span class="number">0</span>] * (n+<span class="number">1</span>)  <span class="comment"># 表示步长</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> vis[i] == <span class="number">0</span>:</span><br><span class="line">        dfs(i, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><ul><li>记得扩栈</li></ul><h1 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>你有一张某海域 NxN 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</p><p>…….</p><p>.##….</p><p>.##….</p><p>….##.</p><p>..####.</p><p>…###.</p><p>…….</p><p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 2 座岛屿。</p><p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p><p>例如上图中的海域未来会变成如下样子：</p><p>…….</p><p>…….</p><p>…….</p><p>…….</p><p>….#..</p><p>…….</p><p>…….</p><p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)  <span class="comment"># 递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="comment"># 当前处于(i,j)位置，标记为已访问</span></span><br><span class="line">    vis[i][j] = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 四个方向进行DFS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">map</span>[i][j-<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> <span class="built_in">map</span>[i][j+<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> <span class="built_in">map</span>[i-<span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> <span class="built_in">map</span>[i+<span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">        <span class="keyword">global</span> flag</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 扩展，把相邻的点打上标记</span></span><br><span class="line">    <span class="keyword">for</span> (dx, dy) <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">        x = i + dx</span><br><span class="line">        y = j + dy</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[x][y] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> vis[x][y]:</span><br><span class="line">            dfs(x, y)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> = []</span><br><span class="line"></span><br><span class="line">vis = []  <span class="comment"># 记录是否访问过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">map</span>.append(<span class="built_in">list</span>(<span class="built_in">input</span>()))</span><br><span class="line">    vis.append([<span class="literal">False</span>] * n)</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">map</span>[i][j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> vis[i][j]:</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            dfs(i, j)</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">DFS回溯</summary>
    
    
    
    <category term="算法" scheme="https://blog.pridelzh.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DFS" scheme="https://blog.pridelzh.top/tags/DFS/"/>
    
    <category term="回溯" scheme="https://blog.pridelzh.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>DFS剪枝</title>
    <link href="https://blog.pridelzh.top/posts/8c023b29.html"/>
    <id>https://blog.pridelzh.top/posts/8c023b29.html</id>
    <published>2025-01-16T08:42:39.000Z</published>
    <updated>2025-08-22T06:25:03.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS剪枝简介"><a href="#DFS剪枝简介" class="headerlink" title="DFS剪枝简介"></a>DFS剪枝简介</h1><p>DFS剪枝是一种启发式搜索算法，它通过对搜索树进行剪枝，来减少搜索树的大小，从而减少搜索时间。</p><p>DFS剪枝的基本思想是，在搜索树的每一步，都要判断是否可以直接跳过某些分支，从而减少搜索树的大小。</p><p>具体来说，DFS剪枝有以下几种方法：</p><ol><li>剪枝准则：在搜索树的每一步，都要判断是否可以直接跳过某些分支，从而减少搜索树的大小。</li><li>启发式函数：启发式函数是指对节点的评估函数，它可以帮助搜索算法更好地选择下一步要探索的节点。</li><li>代价估计：代价估计是指估计节点的代价，并据此来判断是否应该继续探索该节点的子节点。</li><li>动态规划：动态规划是指利用搜索树的结构性质，对搜索树进行预处理，从而减少搜索树的大小。</li><li>启发式搜索：启发式搜索是指利用启发式函数对搜索树进行排序，从而减少搜索树的大小。</li><li>备忘录：备忘录是指在搜索树的每一步，都记录下已经探索过的节点，从而减少搜索树的大小。</li><li>并行搜索：并行搜索是指在多线程或多进程环境下，对搜索树进行搜索，从而减少搜索树的大小。</li><li>剪枝策略：剪枝策略是指对搜索树进行剪枝，从而减少搜索树的大小。</li><li>多目标搜索：多目标搜索是指在搜索树的每一步，都要同时考虑多个目标，从而减少搜索树的大小。</li></ol><h1 id="实例一：学生分队问题"><a href="#实例一：学生分队问题" class="headerlink" title="实例一：学生分队问题"></a>实例一：学生分队问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>数字王国开学了，它们也和我们人类一样有开学前的军训，现在一共有 n 名学生，每个学生有自己的一个名字 ai</p><p>（数字王国里的名字就是一个正整数，注意学生们可能出现重名的情况），此时叛逆教官来看了之后感觉十分别扭，决定将学生重新分队。</p><p>排队规则为：将学生分成若干队，每队里面至少一个学生，且每队里面学生的名字不能出现倍数关系（注意名字相同也算是倍数关系）。</p><p>现在请你帮忙算算最少可以分成几队？</p><p>例：有 4 名学生 (2,3,4,4)，最少可以分成 (2,3)、(4)、(4) 共 3 队。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x, group</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> group:</span><br><span class="line">        <span class="keyword">if</span> y % x == <span class="number">0</span> <span class="keyword">or</span> x % y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">depth</span>):</span><br><span class="line">    <span class="comment"># 最优解的剪枝</span></span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    <span class="comment"># 如果当前分组状态已经比ans大，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Groups) &gt; ans:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前是第depth层</span></span><br><span class="line">    <span class="keyword">if</span> depth == n:</span><br><span class="line">        <span class="keyword">global</span> ans</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">len</span>(Groups))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 每个学生的基础操作</span></span><br><span class="line">    <span class="comment"># 遍历每个分组</span></span><br><span class="line">    <span class="keyword">for</span> every_group <span class="keyword">in</span> Groups:</span><br><span class="line">        <span class="comment"># 可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span> check(a[depth], every_group):</span><br><span class="line">            every_group.append(a[depth])</span><br><span class="line">            dfs(depth+<span class="number">1</span>)</span><br><span class="line">            every_group.pop()</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 单独作为一组</span></span><br><span class="line">    Groups.append([a[depth]])</span><br><span class="line">    dfs(depth+<span class="number">1</span>)</span><br><span class="line">    Groups.pop()    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 学生分组,每个元素是一个列表，表示一个分组</span></span><br><span class="line">Groups = []</span><br><span class="line">ans = n</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">DFS剪枝</summary>
    
    
    
    <category term="算法" scheme="https://blog.pridelzh.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DFS" scheme="https://blog.pridelzh.top/tags/DFS/"/>
    
    <category term="剪枝" scheme="https://blog.pridelzh.top/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>java基础学习</title>
    <link href="https://blog.pridelzh.top/posts/43ebcb2f.html"/>
    <id>https://blog.pridelzh.top/posts/43ebcb2f.html</id>
    <published>2025-01-14T08:42:39.000Z</published>
    <updated>2025-08-22T06:25:39.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h1><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件中可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置 age 的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 age 的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 name 的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>(<span class="string">&quot;Tommy&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过方法来设定 age</span></span><br><span class="line">        myPuppy.setAge(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调用另一个方法获取 age</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myPuppy.getAge();</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗的年龄为 : &quot;</span> + age);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 也可以直接访问成员变量（通过 getter 方法）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;变量值 : &quot;</span> + myPuppy.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java基本数据类型"><a href="#java基本数据类型" class="headerlink" title="java基本数据类型"></a>java基本数据类型</h1><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><ul><li>byte：字节型，8位，有符号整数，范围-128~127。</li><li>short：短整型，16位，有符号整数，范围-32768~32767。</li><li>int：整型，32位，有符号整数，范围-2147483648~2147483647。</li><li>long：长整型，64位，有符号整数，范围-9223372036854775808~9223372036854775807。</li><li>float：单精度浮点型，32位，范围-3.40282347E+38~3.40282347E+38。</li><li>double：双精度浮点型，64位，范围-1.7976931348623157E+308~1.7976931348623157E+308。</li><li>char：字符型，16位，表示单个Unicode字符。</li><li>boolean：布尔型，只有两个值：true和false。</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimitiveTypeTest</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// byte  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：byte 二进制位数：&quot;</span> + Byte.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Byte&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Byte.MIN_VALUE=&quot;</span> + Byte.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Byte.MAX_VALUE=&quot;</span> + Byte.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// short  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：short 二进制位数：&quot;</span> + Short.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Short&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Short.MIN_VALUE=&quot;</span> + Short.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Short.MAX_VALUE=&quot;</span> + Short.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// int  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：int 二进制位数：&quot;</span> + Integer.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Integer&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Integer.MIN_VALUE=&quot;</span> + Integer.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Integer.MAX_VALUE=&quot;</span> + Integer.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// long  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：long 二进制位数：&quot;</span> + Long.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Long&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Long.MIN_VALUE=&quot;</span> + Long.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Long.MAX_VALUE=&quot;</span> + Long.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// float  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：float 二进制位数：&quot;</span> + Float.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Float&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Float.MIN_VALUE=&quot;</span> + Float.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Float.MAX_VALUE=&quot;</span> + Float.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// double  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：double 二进制位数：&quot;</span> + Double.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Double&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Double.MIN_VALUE=&quot;</span> + Double.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Double.MAX_VALUE=&quot;</span> + Double.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// char  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：char 二进制位数：&quot;</span> + Character.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Character&quot;</span>);  </span><br><span class="line">        <span class="comment">// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Character.MIN_VALUE=&quot;</span>  </span><br><span class="line">                + (<span class="type">int</span>) Character.MIN_VALUE);  </span><br><span class="line">        <span class="comment">// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Character.MAX_VALUE=&quot;</span>  </span><br><span class="line">                + (<span class="type">int</span>) Character.MAX_VALUE);  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// boolean  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：boolean 二进制位数：&quot;</span> + Boolean.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Boolean&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;true 的数值：&quot;</span> + Boolean.TRUE.hashCode());  </span><br><span class="line">        System.out.println(<span class="string">&quot;false 的数值：&quot;</span> + Boolean.FALSE.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>Java语言支持自动类型转换，即不同类型的数据可以相互转换。</p><h1 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h1><p>Java语言提供了以下几种变量类型：</p><ul><li>局部变量：在方法、构造器或代码块中声明的变量，只能在声明它们的区域内使用。</li><li>实例变量（成员变量）：在类的声明中声明的变量，可以被所有方法共享，包括方法体外。</li><li>类变量（静态变量）：用 static 关键字修饰的变量，被所有对象共享，静态变量在第一次被访问时被初始化。</li><li>常量：用 final 关键字修饰的变量，只能被赋值一次，常量可以是任何基本类型或引用类型。</li><li>参数变量</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVar;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> paramVar)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用变量</span></span><br><span class="line">        instanceVar = localVar;</span><br><span class="line">        staticVar = paramVar;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量: &quot;</span> + instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量: &quot;</span> + staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数变量: &quot;</span> + paramVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;局部变量: &quot;</span> + localVar);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunoobTest</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunoobTest</span>();</span><br><span class="line">        v.method(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h2><p>Java 中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>Java 的局部变量是在方法、构造方法或语句块内部声明的变量，其作用域限制在声明它的代码块内部。</p><h2 id="成员变量（实例变量）"><a href="#成员变量（实例变量）" class="headerlink" title="成员变量（实例变量）"></a>成员变量（实例变量）</h2><p>成员变量（实例变量）是指在类的声明中声明的变量，可以被所有方法共享，包括方法体外。</p><h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>Java 中的静态变量是指在类中定义的一个变量，它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。<br>静态变量在类加载时被创建，在整个程序运行期间都存在。</p><h1 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h1><p>Java 修饰符用来控制成员（类、方法、变量）的访问权限、继承性、多态性等。</p><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><ul><li>public：公共修饰符，可以被所有类访问，默认继承。</li><li>private：私有修饰符，只能被当前类访问。</li><li>protected：受保护修饰符，同包内的类可以访问，不同包的子类可以访问。</li><li>default：默认修饰符，同包内的类可以访问，不同包的子类不能访问。</li></ul><h2 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h2><ul><li>abstract：抽象修饰符，用来创建抽象类和抽象方法。</li><li>final：最终修饰符，用来修饰类、方法、变量，防止它们被继承、修改。</li><li>static：静态修饰符，用来创建静态成员。</li><li>synchronized：同步修饰符，用来在多线程环境下同步访问资源。</li><li>volatile：易失修饰符，用来在多线程环境下保证变量的可见性。</li><li>transient：瞬时修饰符，用来在序列化时忽略该变量。</li></ul><h1 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h1><p>Java 运算符是用来执行各种操作的符号。Java 运算符分为以下几类：</p><ul><li><p>算术运算符</p><p>用于执行基本的算术运算，如加减乘除、取模等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;a + b = &quot;</span> + (a + b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a - b = &quot;</span> + (a - b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a * b = &quot;</span> + (a * b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;b / a = &quot;</span> + (b / a) );</span><br><span class="line">   System.out.println(<span class="string">&quot;b % a = &quot;</span> + (b % a) );</span><br><span class="line">   System.out.println(<span class="string">&quot;c % a = &quot;</span> + (c % a) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a++   = &quot;</span> +  (a++) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a--   = &quot;</span> +  (a--) );</span><br><span class="line">   <span class="comment">// 查看  d++ 与 ++d 的不同</span></span><br><span class="line">   System.out.println(<span class="string">&quot;d++   = &quot;</span> +  (d++) );</span><br><span class="line">   System.out.println(<span class="string">&quot;++d   = &quot;</span> +  (++d) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关系运算符</p><p>用于比较两个值之间的关系，如大于、小于、等于、不等于等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;a == b = &quot;</span> + (a == b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a != b = &quot;</span> + (a != b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a &gt; b = &quot;</span> + (a &gt; b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;a &lt; b = &quot;</span> + (a &lt; b) );</span><br><span class="line">   System.out.println(<span class="string">&quot;b &gt;= a = &quot;</span> + (b &gt;= a) );</span><br><span class="line">   System.out.println(<span class="string">&quot;b &lt;= a = &quot;</span> + (b &lt;= a) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">java基础学习</summary>
    
    
    
    <category term="java" scheme="https://blog.pridelzh.top/categories/java/"/>
    
    
    <category term="java" scheme="https://blog.pridelzh.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>dfs</title>
    <link href="https://blog.pridelzh.top/posts/4a345649.html"/>
    <id>https://blog.pridelzh.top/posts/4a345649.html</id>
    <published>2025-01-13T14:58:08.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS基础"><a href="#DFS基础" class="headerlink" title="DFS基础"></a>DFS基础</h1><h2 id="DFS和n重循环"><a href="#DFS和n重循环" class="headerlink" title="DFS和n重循环"></a>DFS和n重循环</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">depth</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param depth: 记录当前深度</span></span><br><span class="line"><span class="string">    :return </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> depth == N:</span><br><span class="line">      <span class="comment"># N重循环最内层执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="comment"># 每重循环进行的枚举选择</span></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1-打印相加为X的非严格递增n位序列"><a href="#1-打印相加为X的非严格递增n位序列" class="headerlink" title="1. 打印相加为X的非严格递增n位序列"></a>1. 打印相加为X的非严格递增n位序列</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">depth, last_value</span>):</span><br><span class="line">    <span class="comment">#depth:表示当前处于第depth层</span></span><br><span class="line">    <span class="comment">#递归入口</span></span><br><span class="line">    <span class="keyword">if</span> depth == n:</span><br><span class="line">        <span class="comment">#判断是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(path) != x:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(last_value,x+<span class="number">1</span>):</span><br><span class="line">        path[depth] = i</span><br><span class="line">        dfs(depth+<span class="number">1</span>,i)</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># path[i]表示第i个位置的值</span></span><br><span class="line">path = [<span class="number">0</span>]*n</span><br><span class="line"><span class="comment"># x = 6</span></span><br><span class="line"><span class="comment"># n = 3</span></span><br><span class="line"><span class="comment"># [0,0,0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">dfs简单讲述</summary>
    
    
    
    <category term="学习" scheme="https://blog.pridelzh.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="dfs" scheme="https://blog.pridelzh.top/tags/dfs/"/>
    
    <category term="算法" scheme="https://blog.pridelzh.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>电子技术的作用</title>
    <link href="https://blog.pridelzh.top/posts/1.html"/>
    <id>https://blog.pridelzh.top/posts/1.html</id>
    <published>2025-01-13T10:29:00.000Z</published>
    <updated>2025-08-31T01:43:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电子计技术对于计算机发展的推动——以中央处理器（CPU）为例"><a href="#电子计技术对于计算机发展的推动——以中央处理器（CPU）为例" class="headerlink" title="电子计技术对于计算机发展的推动——以中央处理器（CPU）为例"></a>电子计技术对于计算机发展的推动——以中央处理器（CPU）为例</h1><p><strong>摘要</strong>：随着电子技术的不断创新和进步，计算机的性能和功能得到了进一步的发展。本文聚焦于计算机的中央处理器（CPU），通过阐述其随着电子技术发展而产生的变化历程，深入剖析电子技术对计算机硬件发展的推动作用，展现二者紧密的关联及电子技术的重要影响力。</p><p><strong>关键词</strong>：电子技术，CPU，集成电路，芯片，算力，人工智能，机器学习，大数据</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>计算机作为现代社会不可或缺的工具，其性能的不断提升得益于硬件的持续发展。而在众多计算机硬件部件中，中央处理器（CPU）无疑起着核心作用，它的发展演变与电子技术的进步息息相关，电子技术的每一次突破都为 CPU 的性能提升带来了新的契机。其中，也诞生了计算机历史上比较著名的定理，如摩尔定理，即每过 18 个月，中央处理器（CPU）的价格下降一半，性能提高一倍。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="电子技术发展初期和早期-CPU"><a href="#电子技术发展初期和早期-CPU" class="headerlink" title="电子技术发展初期和早期 CPU"></a>电子技术发展初期和早期 CPU</h3><p>在电子技术发展的早期阶段，那时主要采用电子管技术。世界上第一台通用计算机 ENIAC 便是以电子管作为基础元件构建其 CPU 等部件的。电子管体积庞大、能耗极高且容易损坏，这使得当时的 CPU 运算速度慢、处理能力有限，计算机整体体积也十分巨大，只能应用于一些特定的科研等领域。不过，电子管的出现也开启了利用电子技术打造计算机核心部件的大门，为后续发展奠定了基础。自从世纪的计算机创立之后，无论是作为一门学科还是一种器件，计算机的作用都巨大，有着 21 世纪工业奇迹的美誉，这当然要归功于电子管技术向晶体管技术发展，使得电子计算机不断小型化，家庭化。</p><p>第一代电子计算机采用的电子管元件有许多明显缺点，如，在运行时产生的热量太多，可靠性较差，运算速度不快，价格昂贵，体积庞大，这些都使计算机发展受限。第二代电子计算机时代是从 1958 年到 1964 年，第二代电子计算机全部采用晶体管作为电子器件，其运算速度比第一代电子计算机的运算速度提高了近百倍，体积为原来的几十分之一。[1]</p><p>随着晶体管的发明，电子技术迎来了重大变革。晶体管相比于电子管，体积大幅缩小、功耗显著降低且可靠性增强。基于晶体管技术的 CPU 开始出现，像第二代计算机的 CPU 便采用了晶体管，这使得计算机的运算速度有了明显提升，而且计算机的体积也得以缩小，应用范围开始逐渐拓展到商业等更多领域，电子技术的这一进步让 CPU 在性能和适用性上迈出了重要的一步。</p><h3 id="集成电路时代的-GPU-变革"><a href="#集成电路时代的-GPU-变革" class="headerlink" title="集成电路时代的 GPU 变革"></a>集成电路时代的 GPU 变革</h3><p>集成电路的诞生更是电子技术发展的一座里程碑。它将众多的晶体管等元件集成到一块小小的芯片上，极大地提高了电子元件的集成度。当 CPU 开始采用集成电路技术后，性能得到了质的飞跃。例如，英特尔公司早期推出的基于集成电路的 CPU 产品，能够在更小的空间内实现更复杂的运算逻辑，使得计算机的处理能力大大增强，运算速度成倍增长，并且计算机的体积进一步缩小，成本也有所降低，个人计算机开始逐渐走入普通家庭，这一切都得益于集成电路这种电子技术成果对 CPU 的重塑。</p><p>集成电路下，原本庞大的计算机处理中心转化为一小块的芯片，使得计算机的体积进一步减小，以英特尔为代表的一些芯片公司得到发展，个人便携式计算机逐渐问世。</p><p>集成电路的发展导致了两个效应：一方面，晶体管的面积要求减小了，因此可以在芯片上容纳更多的晶体管（集成度提高），从而在同样的芯片面积上实现更多的功能。另一方面，晶体管的开关速度更快，因此电路可以以更高的时钟频率运行，进而提高了计算能力。[2]</p><h3 id="超大规模集成电路下的-CPU-现状"><a href="#超大规模集成电路下的-CPU-现状" class="headerlink" title="超大规模集成电路下的 CPU 现状"></a>超大规模集成电路下的 CPU 现状</h3><p>如今，我们处于超大规模集成电路的时代，在一块 CPU 芯片上可以集成数以亿计的晶体管。电子技术在微纳加工等方面不断精进，使得 CPU 的制程越来越小，比如已经从早期的微米级别发展到如今的纳米级别。这不仅让 CPU 的运算速度达到了惊人的程度，而且在多核心、多线程等技术方面也不断突破，能够同时处理海量的复杂任务，计算机的性能也随之达到了前所未有的高度，满足了当下人们在人工智能、大数据处理等众多领域对高性能计算的需求。</p><p>如今状态下，计算机的芯片晶体管密度可以达到 180 亿次，设计制程可以达到 3nm 水平，全球诞生了一系列的芯片设计公司如 Apple 公司，海思芯片公司等，还有许多的芯片制造公司，如台积电公司，荷兰阿斯麦公司。</p><p>同时，超大规模集成电路下的 CPU，也就是我们俗称的芯片，伴随着晶体管密度的上升，算力不断提升，为将来的人工智能，大数据等科学的发展做了很多的铺垫。</p><h3 id="新时代下-CPU-的发展趋势"><a href="#新时代下-CPU-的发展趋势" class="headerlink" title="新时代下 CPU 的发展趋势"></a>新时代下 CPU 的发展趋势</h3><p>虽然说目前的的芯片晶体管的密度十分高，算力十分强，但是仍然有许多的不足，比如目前的生成式人工智能愈发流行，很多模型的训练需要耗费大量的算力，这当然可以通过 GPU 来进行弥补，但是很多时候，CPU 的性能仍然需要不断提升，才能够提高兼容性，许多计算机面临着内置集成 AI 的需求，这对于 CPU 的性能要求就更高了。所以，目前有很多的新的发展趋势，</p><p>芯粒设计和芯片三维堆叠系统的集成技术，是未来算力提升过程中工艺实现的手段和方法。芯粒和传统的裸芯片区别巨大。芯粒是一种特殊的裸芯片，它有特定功能和标准互连结构多个芯粒可以在在封装级进行组合并形成完整的微系统。这需要从“复用”的角度来考虑这一问题，芯粒单一使用次数相对而言比较多的，但还没有达到“复用”模式。多芯粒具有集成优势，用成熟工艺来实现芯粒可以有效降低成本。基于芯粒的集成并不依照摩尔定律只追求高功率线宽，第二个更小的裸芯片面积更小，对良率的提升具有非常大的价值。[3]</p><p>所以按照目前的趋势来看，芯片（CPU）的发展会向着多芯粒的方向不断发展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结来看电子技术对于计算机发展的推动十分明显，无论是从存储器，显示器，还是本文所聚焦的中央处理器，本文所聚焦的中央处理器，是计算机运算的核心，从第一代的电子管到后来的晶体管，以及后来的高密度的晶体管，到未来可能会有希望出现的芯粒设计和芯片堆叠，无不展现了 CPU 对于计算机的重要影响。</p><p>在未来，更多新兴的电子技术肯定还会在其他方面继续影响电子计算机的发展，甚至可能会对计算机的形态和运算原理产生深远影响，所以我们一定要关于电子技术，并及时在计算机领域运用相关技术。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1]俞望年.电子计算机的出现与发展(下)[J].少儿科技,2021,(Z2):72-73.<br>[2]吴川斌.飞跃 80 年：计算机的诞生与发展[J].中国工业和信息化,2024,(12):68-73.DOI:10.19609&#x2F;j.cnki.cn10-1299&#x2F;f.2024.12.002.<br>[3]黄思维.后摩尔时代芯片算力提升的途径[J].高科技与产业化,2022,28(01):58-61.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电子计技术对于计算机发展的推动——以中央处理器（CPU）为例&quot;&gt;&lt;a href=&quot;#电子计技术对于计算机发展的推动——以中央处理器（CPU）为例&quot; class=&quot;headerlink&quot; title=&quot;电子计技术对于计算机发展的推动——以中央处理器（CPU）为例&quot;&gt;</summary>
      
    
    
    
    <category term="电子技术" scheme="https://blog.pridelzh.top/categories/%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
    
    <category term="开发" scheme="https://blog.pridelzh.top/categories/%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="电子技术" scheme="https://blog.pridelzh.top/tags/%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://blog.pridelzh.top/posts/0.html"/>
    <id>https://blog.pridelzh.top/posts/0.html</id>
    <published>2025-01-12T04:00:00.000Z</published>
    <updated>2025-08-22T06:11:01.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>这是我的第一篇博客，欢迎大家来阅读！</p><p>经过了九九八十一难，我终于短暂地建立了本站，虽然目前上有很多的地方不完善，终归已经有了眉目，谢谢大家的关注</p><p>我以后会不断地完善本站，并尽可能地将自己的心得体会，创作记录在本站上，有需要或者感兴趣的同学朋友，可以参考学习</p><p>希望我们能够共同进步，也欢迎各位同学朋友积极留言。</p><p>嘻嘻happy，现在可以在电脑网页上直接发博客了，以后会加快更新频率的😎 </p><!-- more -->]]></content>
    
    
    <summary type="html">第一篇博客 这是我的第一篇博客，欢迎大家来阅读！ 经过了九九八十一难，我终于短暂地建立了本站，虽然目前上有很多的地方不完善，终归已经有了眉目，谢谢大家的关注 我以后会不断地完善本站，并尽可能地将自己的心得体会，创作记录在本站上，有需要或者感兴趣的同学朋友，可以参考学习 希望我们能够共同进步，也欢迎各位同学朋友积极留言。 嘻嘻happy，现在可以在电脑网页上直接发博客了，以后会加快更新频率的😎 ...</summary>
    
    
    
    <category term="大学" scheme="https://blog.pridelzh.top/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://blog.pridelzh.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
